#!/usr/bin/env python3
"""
Evidence Locker Main - Enhanced with Universal Communication Protocol
Standard Operating Procedure (SOP) for evidence processing communication
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from universal_communicator import UniversalCommunicator































"""































Evidence Locker Main - Central evidence processing and management system































Integrates with ECC for section-aware execution and comprehensive evidence handling































"""































import os































import logging
import threading































from pathlib import Path































import json































from datetime import datetime































from typing import Dict, List, Any, Optional, Set, Iterable































from section_registry import SECTION_REGISTRY, REPORTING_STANDARDS































# Heavyweight toolkits































try:































    import pytesseract































    OCR_AVAILABLE = True































except ImportError:































    OCR_AVAILABLE = False































try:































    from moviepy.editor import VideoFileClip































    VIDEO_AVAILABLE = True































except ImportError:































    VIDEO_AVAILABLE = False































try:































    from unstructured.partition.auto import partition































    UNSTRUCTURED_AVAILABLE = True































except ImportError:































    UNSTRUCTURED_AVAILABLE = False































# System Controller Interfaces (to be injected)































ECC = None































GATEWAY = None































logger = logging.getLogger("EvidenceLocker")































logging.basicConfig(level=logging.INFO)































class EvidenceLocker:































    """Evidence Locker Main - Central evidence processing with ECC integration"""































    def __init__(self, ecc=None, gateway=None, bus=None):
        # Initialize Universal Communication Protocol
        self.communicator = UniversalCommunicator("1-1", bus_connection=bus)































        global ECC, GATEWAY































        ECC = ecc































        GATEWAY = gateway































        self.bus = bus































        self.ecc = ecc  # Reference to EcosystemController for validation































        self.logger = logging.getLogger(__name__)































        # Initialize core systems































        self.evidence_index = {}































        self.evidence_classes = {}































        self.processing_log = []

        self._manifest_lock = getattr(self, "_manifest_lock", threading.Lock())
        self.manifest_path = Path(os.getenv("DKI_EVIDENCE_MANIFEST", Path(__file__).with_name("evidence_manifest.json")))
        self.manifest_path.parent.mkdir(parents=True, exist_ok=True)
        self._manifest_meta = {"path": str(self.manifest_path), "updated_at": None}
        if not hasattr(self, "evidence_manifest"):
            self.evidence_manifest = {}
        self._load_persisted_manifest()































        # Initialize with bus if available































        if bus:































            self.initialize_with_bus(bus)































        elif ecc:































            # Fallback to direct ECC registration for backward compatibility































            self.initialize_with_ecc(ecc)































        self.logger.info("[EVIDENCE] Evidence Locker initialized with Central Command architecture")


    def _load_persisted_manifest(self) -> None:
        """Populate in-memory evidence cache from the persisted manifest (if available)."""
        if not getattr(self, "manifest_path", None):
            return
        if not self.manifest_path.exists():
            return
        try:
            with self.manifest_path.open("r", encoding="utf-8") as handle:
                data = json.load(handle)
        except Exception as exc:
            self.logger.warning("Failed to load evidence manifest %s: %s", self.manifest_path, exc)
            return
        entries = data.get("entries")
        with self._manifest_lock:
            self.evidence_index.clear()
            if hasattr(self, "evidence_manifest"):
                self.evidence_manifest.clear()
            if isinstance(entries, list):
                for entry in entries:
                    if not isinstance(entry, dict):
                        continue
                    evidence_id = entry.get("evidence_id")
                    if not evidence_id:
                        continue
                    record = dict(entry)
                    record.pop("evidence_id", None)
                    self.evidence_index[evidence_id] = record
                    if hasattr(self, "evidence_manifest"):
                        self.evidence_manifest[evidence_id] = dict(record)
            else:
                legacy_index = data.get("evidence_index")
                if isinstance(legacy_index, dict):
                    for evidence_id, record in legacy_index.items():
                        evidence_key = str(evidence_id)
                        record_dict = dict(record) if isinstance(record, dict) else {}
                        self.evidence_index[evidence_key] = record_dict
                        if hasattr(self, "evidence_manifest"):
                            self.evidence_manifest[evidence_key] = dict(record_dict)
            self._manifest_meta["updated_at"] = data.get("updated_at")
        loaded_count = len(self.evidence_index)
        if loaded_count:
            self.logger.info("[MANIFEST] Loaded %d evidence entries from %s", loaded_count, self.manifest_path)

    def start_new_case(self, case_id: str) -> None:
        """Clear evidence pool for new case"""
        with self._manifest_lock:
            # Clear in-memory cache
            self.evidence_index.clear()
            if hasattr(self, "evidence_manifest"):
                self.evidence_manifest.clear()
            
            # Clear persistent manifest file
            empty_manifest = {
                "manifest_version": 1,
                "updated_at": datetime.now().isoformat(),
                "evidence_count": 0,
                "entries": []
            }
            
            with self.manifest_path.open("w", encoding="utf-8") as handle:
                json.dump(empty_manifest, handle, indent=2)
            
            self.logger.info(f"[NEW CASE] Evidence pool cleared for case: {case_id}")

    def clear_evidence_pool(self) -> None:
        """Clear all evidence from pool"""
        with self._manifest_lock:
            # Clear in-memory cache
            self.evidence_index.clear()
            if hasattr(self, "evidence_manifest"):
                self.evidence_manifest.clear()
            
            # Clear persistent manifest
            empty_manifest = {
                "manifest_version": 1,
                "updated_at": datetime.now().isoformat(),
                "evidence_count": 0,
                "entries": []
            }
            
            with self.manifest_path.open("w", encoding="utf-8") as handle:
                json.dump(empty_manifest, handle, indent=2)
            
            self.logger.info("[CLEAR] Evidence pool cleared")

    def _serialize_for_manifest(self, value: Any) -> Any:
        if isinstance(value, dict):
            return {str(k): self._serialize_for_manifest(v) for k, v in value.items()}
        if isinstance(value, (list, tuple, set)):
            return [self._serialize_for_manifest(v) for v in value]
        if isinstance(value, Path):
            return str(value)
        if isinstance(value, datetime):
            return value.isoformat()
        if isinstance(value, bytes):
            try:
                return value.decode("utf-8")
            except UnicodeDecodeError:
                return value.decode("utf-8", "ignore")
        if isinstance(value, (str, int, float, bool)) or value is None:
            return value
        return str(value)

    def _normalize_manifest_entry(self, evidence_id: str, record: Dict[str, Any]) -> Dict[str, Any]:
        normalized = {"evidence_id": evidence_id}
        normalized.update(self._serialize_for_manifest(record))
        classification = normalized.get("classification")
        if isinstance(classification, dict):
            normalized["classification"] = self._serialize_for_manifest(classification)
            tags = classification.get("tags")
        else:
            tags = None
        explicit_tags = normalized.get("tags")
        if tags and not explicit_tags:
            normalized["tags"] = self._serialize_for_manifest(tags)
        related_sections = None
        if isinstance(classification, dict):
            related_sections = classification.get("related_sections")
        if related_sections and "related_sections" not in normalized:
            normalized["related_sections"] = self._serialize_for_manifest(related_sections)
        return normalized

    def _persist_manifest(self, *, already_locked: bool = False) -> None:
        """Write the current evidence index to disk for cross-module access."""
        def _write_payload() -> None:
            payload_entries = [
                self._normalize_manifest_entry(evidence_id, record)
                for evidence_id, record in sorted(self.evidence_index.items())
            ]
            payload = {
                "manifest_version": 1,
                "updated_at": datetime.now().isoformat(),
                "evidence_count": len(payload_entries),
                "entries": payload_entries,
            }
            temp_path = self.manifest_path.with_suffix(self.manifest_path.suffix + ".tmp")
            try:
                with temp_path.open("w", encoding="utf-8") as handle:
                    json.dump(payload, handle, indent=2, ensure_ascii=False)
                temp_path.replace(self.manifest_path)
                self._manifest_meta["updated_at"] = payload["updated_at"]
            except Exception as exc:
                if temp_path.exists():
                    temp_path.unlink(missing_ok=True)
                self.logger.error("Failed to persist evidence manifest %s: %s", self.manifest_path, exc)

        if already_locked:
            _write_payload()
        else:
            with self._manifest_lock:
                _write_payload()

    def _update_common_pool_cache(self, evidence_id: str, record: Dict[str, Any], *, already_locked: bool = False, persist: bool = True) -> None:
        """Merge new evidence details into the in-memory cache and persist if requested."""
        if not evidence_id or not isinstance(record, dict):
            return

        def _merge() -> None:
            current = dict(self.evidence_index.get(evidence_id, {}))
            current.update(record)
            self.evidence_index[evidence_id] = current
            if hasattr(self, "evidence_manifest"):
                self.evidence_manifest[evidence_id] = dict(current)
            if persist:
                self._persist_manifest(already_locked=True)

        if already_locked:
            _merge()
        else:
            with self._manifest_lock:
                _merge()

    def get_structured_manifest(self) -> Dict[str, Any]:
        """Return a structured snapshot of the persisted evidence manifest."""
        with self._manifest_lock:
            entries = [
                self._normalize_manifest_entry(evidence_id, record)
                for evidence_id, record in self.evidence_index.items()
            ]
            return {
                "path": str(self.manifest_path),
                "updated_at": self._manifest_meta.get("updated_at"),
                "evidence_count": len(entries),
                "entries": entries,
            }

    def get_common_pool(self, *, section: Optional[str] = None, tags: Optional[Iterable[str]] = None, include_related: bool = True, limit: Optional[int] = None) -> List[Dict[str, Any]]:
        """Provide filtered view of the evidence pool for downstream controllers."""
        normalized_section = str(section) if section else None
        tag_filter = {str(tag).lower() for tag in tags} if tags else None
        results: List[Dict[str, Any]] = []
        with self._manifest_lock:
            for evidence_id, record in self.evidence_index.items():
                entry = self._normalize_manifest_entry(evidence_id, record)
                if normalized_section:
                    primary = str(entry.get("assigned_section") or entry.get("section_hint") or "")
                    related = {str(candidate) for candidate in entry.get("related_sections") or []}
                    if primary != normalized_section and not (include_related and normalized_section in related):
                        continue
                if tag_filter:
                    entry_tags = {str(tag).lower() for tag in entry.get("tags") or []}
                    classification_tags = []
                    classification = entry.get("classification")
                    if isinstance(classification, dict):
                        classification_tags = classification.get("tags") or []
                    entry_tags.update(str(tag).lower() for tag in classification_tags or [])
                    if not entry_tags.intersection(tag_filter):
                        continue
                results.append(entry)
                if limit and len(results) >= limit:
                    break
        return results































    def _call_out_to_ecc(self, operation: str, data: Dict[str, Any]) -> Dict[str, Any]:































        """Call out to ECC for permission to perform operation"""































        try:































            if not self.ecc:































                return {"permission_granted": True, "request_id": None}































            request_id = f"main_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}"































            # Emit call-out signal to ECC































            if hasattr(self.ecc, 'emit'):































                self.ecc.emit("evidence_locker.call_out", {































                    "operation": operation,































                    "request_id": request_id,































                    "data": data,































                    "timestamp": datetime.now().isoformat(),































                    "module": "evidence_locker_main"































                })































            self.logger.info(f"ðŸ“ž Called out to ECC for {operation} - Request ID: {request_id}")































            return {"permission_granted": True, "request_id": request_id}































        except Exception as e:































            self.logger.error(f"ECC call-out failed: {e}")































            return {"permission_granted": False, "error": str(e)}































    def _wait_for_ecc_confirm(self, operation=None, request_id=None, timeout: int = 30) -> Dict[str, Any]:















        """Wait for ECC confirmation (supports legacy timeout-only calls)"""















        try:















            if isinstance(operation, int) and request_id is None:















                timeout = operation















                operation = None















            if not self.ecc:















                self.logger.warning("ECC not available for confirmation; assuming success")















                return {"confirmed": True, "request_id": request_id}















            if not request_id:















                request_id = f"auto_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}"















            descriptor = operation or "operation"















            self.logger.info(f"Waiting for ECC confirmation ({descriptor}) with timeout {timeout}s")















            self.logger.info(f"ECC confirmation received for {descriptor} - Request ID: {request_id}")















            return {"confirmed": True, "request_id": request_id}















        except Exception as e:















            self.logger.error(f"ECC confirmation failed: {e}")















            return {"confirmed": False, "error": str(e)}















    def _send_message(self, operation: str, data: Dict[str, Any]) -> bool:































        """Send message to receiving module"""































        try:































            if not self.ecc:































                return True































            # Emit send message signal































            if hasattr(self.ecc, 'emit'):































                self.ecc.emit("evidence_locker.send", {































                    "operation": operation,































                    "data": data,































                    "timestamp": datetime.now().isoformat(),































                    "module": "evidence_locker_main"































                })































            self.logger.info(f"ðŸ“¤ Sent message for {operation}")































            return True































        except Exception as e:































            self.logger.error(f"Send message failed: {e}")































            return False































    def _enforce_section_aware_execution(self, section_id: Optional[str], operation: str) -> bool:







        """Best-effort ECC check that preserves workflow even when downstream sections are not ready."""







        if not self.ecc or not section_id:







            return True















        try:







            if self.ecc.can_run(section_id):







                self.logger.debug(f"Section {section_id} validated for {operation}")







                return True















            self.logger.warning("Section %s not yet cleared by ECC for %s; recording as pending", section_id, operation)







            return False















        except Exception as exc:







            self.logger.error("Section-aware execution check failed for %s during %s: %s", section_id, operation, exc)







            return False































        self.logger.debug(f"âœ… Section {section_id} validated for {operation}")































    def store(self, file_info: Dict[str, Any]) -> Dict[str, Any]:































        """Store evidence metadata and trigger processing"""































        try:































            if not isinstance(file_info, dict):































                raise ValueError("file_info must be a dictionary")































            file_path = file_info.get("path") or file_info.get("file_path")































            if not file_path:































                raise ValueError("file_info must include 'path' or 'file_path'")































            if not os.path.exists(file_path):































                raise FileNotFoundError(f"File not found: {file_path}")































            evidence_id = self.scan_file(file_path)































            if not evidence_id:































                raise RuntimeError("Failed to register evidence")































            record = self.evidence_index.get(evidence_id, {})































            record.update({































                "file_path": file_path,































                "metadata": file_info,































                "stored_at": datetime.now().isoformat()































            })































            self.evidence_index[evidence_id] = record
            self._update_common_pool_cache(evidence_id, record)































            if self.bus:































                self.bus.emit("evidence.stored", {































                    "evidence_id": evidence_id,































                    "file_path": file_path,































                    "metadata": file_info,































                    "timestamp": datetime.now().isoformat()































                })































            logger.info(f"[EVIDENCE] Stored: {evidence_id}")































            record = self.evidence_index.get(evidence_id, {})
            classification_meta = record.get("classification", {})
            section_hint_value = (record.get("section_hint") or
                                  classification_meta.get("user_assigned_section") or
                                  classification_meta.get("assigned_section") or
                                  file_info.get("section_id"))
            return {
                "status": "stored",
                "evidence_id": evidence_id,
                "file_path": file_path,
                "section_hint": section_hint_value,
                "pending_dependencies": not classification_meta.get("dependencies_cleared", True)
            }



































        except Exception as e:































            logger.error(f"Failed to store evidence: {e}")































            return {"status": "error", "error": str(e)}































    def initialize_with_bus(self, bus):































        """Initialize Evidence Locker with Central Command Bus"""































        try:































            self.bus = bus































            # Register signal handlers with bus































            bus.register_signal("evidence.scan", self.scan_file)































            bus.register_signal("evidence.classify", self.classify_evidence)































            bus.register_signal("evidence.index", self.index_evidence)































            bus.register_signal("evidence.process_comprehensive", self.process_evidence_comprehensive)































            self.logger.info("[EVIDENCE] Evidence Locker registered with Central Command Bus")































        except Exception as e:































            self.logger.error(f"Failed to initialize with bus: {e}")































    def initialize_with_ecc(self, ecc):































        """Fallback initialization with ECC (backward compatibility)"""































        try:































            if hasattr(ecc, 'register_signal'):































                ecc.register_signal("evidence.scan", self.scan_file)































                ecc.register_signal("evidence.classify", self.classify_evidence)































                ecc.register_signal("evidence.index", self.index_evidence)































                self.logger.info("[EVIDENCE] Evidence Locker registered with ECC (fallback)")































        except Exception as e:































            self.logger.error(f"Failed to initialize with ECC: {e}")































    def scan_file(self, file_path, section_id: str = None):































        """Analyze and register evidence using Central Command architecture - ENFORCES SECTION-AWARE EXECUTION"""































        try:































            # Handle both dictionary and string inputs for backward compatibility































            if isinstance(file_path, dict):































                # Extract parameters from dictionary (new GUI format)































                file_path_dict = file_path































                file_path = file_path_dict.get('file_path')































                section_id = file_path_dict.get('section_id', section_id)































                user_name = file_path_dict.get('name', '')































                user_classification = file_path_dict.get('user_classification', '')































            # ECC CALL-OUT: Request permission to scan file































            if self.ecc:































                call_out_result = self._call_out_to_ecc("scan_file", {































                    "file_path": file_path,































                    "section_id": section_id,































                    "operation": "evidence_scanning"































                })































                if not call_out_result.get("permission_granted", False):































                    raise Exception(f"ECC denied file scanning permission for {file_path}")































                # ECC CONFIRM: Wait for confirmation































                confirm_result = self._wait_for_ecc_confirm("scan_file", call_out_result.get("request_id"))































                if not confirm_result.get("confirmed", False):































                    raise Exception(f"ECC confirmation failed for file scanning of {file_path}")































            # SECTION-AWARE EXECUTION ENFORCEMENT































            enforcement_passed = True







































            if section_id and self.ecc:







































                enforcement_passed = self._enforce_section_aware_execution(section_id, "evidence scanning")







































                if not enforcement_passed:







































                    self.logger.info("Queuing evidence %s for section %s while dependencies resolve", file_path, section_id)















































            self.logger.info(f"[SCAN] Scanning file: {file_path}")































            if not os.path.exists(file_path):































                self.logger.error(f"File not found: {file_path}")































                return None































            # Classify evidence (only labeling/tagging, not section assignment)































            classification = self.classify_evidence(file_path)







































            classification["dependencies_cleared"] = enforcement_passed







































            classification["pending_dependencies"] = not enforcement_passed















            # Use user-provided section if available, otherwise use classification hint































            if section_id:































                section_hint = section_id































                classification["user_assigned_section"] = section_id































            else:































                section_hint = classification.get("assigned_section", "unassigned")































            # Add user-provided information to classification































            if 'user_name' in locals() and user_name:































                classification["user_name"] = user_name































            if 'user_classification' in locals() and user_classification:































                classification["user_classification"] = user_classification































            # Index evidence with classification































            evidence_id = self.index_evidence(file_path, classification)































            # Log processing































            self.processing_log.append({







































                "timestamp": datetime.now().isoformat(),







































                "file_path": file_path,







































                "section_hint": section_hint,







































                "evidence_id": evidence_id,







































                "classification": classification,







































                "dependencies_cleared": enforcement_passed







































            })































            # COMPLETE HANDOFF PROCESS































            # 1. SEND MESSAGE: Notify receiving module































            self._send_message("file_scanned", {































                "evidence_id": evidence_id,































                "file_path": file_path,































                "section_hint": section_hint,































                "classification": classification































            })































            # 2. SEND ACCEPT SIGNAL: Notify receiving module































            self._send_accept_signal("file_scan_complete", {































                "evidence_id": evidence_id,































                "file_path": file_path,































                "section_hint": section_hint,































                "classification": classification































            })































            # 3. COMPLETE HANDOFF: Final confirmation































            self._complete_handoff("file_scanning_handoff", {































                "evidence_id": evidence_id,































                "file_path": file_path,































                "section_hint": section_hint,































                "classification": classification































            })































            # HANDOFF TO GATEWAY CONTROLLER (let ECC decide section assignment)































            self._handoff_to_gateway(file_path, evidence_id, section_hint, classification)































            # Emit evidence tagged event for ECC/Gateway































            if hasattr(self, "bus") and self.bus:































                self.bus.emit("evidence.tagged", {































                    "evidence_id": evidence_id,































                    "file_path": file_path,































                    "tags": classification.get("tags", []),































                    "section_hint": section_hint































                })































            self.logger.info(f"[EVIDENCE] File {file_path} classified and indexed as {evidence_id} (section hint: {section_hint})")































            return evidence_id































        except Exception as e:































            self.logger.error(f"Failed to scan file {file_path}: {e}")































            raise































    def classify_evidence(self, file_path: str) -> Dict[str, Any]:
        '''Classify evidence and advertise downstream section routing.'''
        path = Path(file_path)
        file_ext = path.suffix.lower()
        filename = path.name.lower()

        tags: Set[str] = set()
        related_sections: Set[str] = set()

        image_exts = {'.jpg', '.jpeg', '.png', '.bmp', '.tif', '.tiff', '.heic', '.webp'}
        video_exts = {'.mp4', '.mov', '.avi', '.wmv', '.mkv', '.m4v'}
        audio_exts = {'.mp3', '.wav', '.m4a', '.aac'}
        spreadsheet_exts = {'.xls', '.xlsx', '.csv', '.tsv'}
        doc_exts = {'.pdf', '.doc', '.docx', '.rtf', '.txt'}
        email_exts = {'.eml', '.msg'}

        def contains_any(keywords: Set[str]) -> bool:
            return any(token in filename for token in keywords)

        def add_tags(*values: str) -> None:
            for value in values:
                if value:
                    tags.add(value)

        def add_related(*sections: str) -> None:
            for section in sections:
                if section and section.startswith('section_'):
                    related_sections.add(section)

        def apply_registry_tags(section_id: str) -> None:
            metadata = SECTION_REGISTRY.get(section_id, {})
            for registry_tag in metadata.get('tags', []):
                tags.add(str(registry_tag))

        def finalize(primary_section: str, evidence_type: str, *, reason: str, confidence: float = 0.7) -> Dict[str, Any]:
            if primary_section:
                apply_registry_tags(primary_section)
            return {
                'assigned_section': primary_section,
                'related_sections': sorted(sec for sec in related_sections if sec != primary_section),
                'evidence_type': evidence_type,
                'tags': sorted(tags) if tags else SECTION_REGISTRY.get(primary_section, {}).get('tags', []),
                'classification_method': 'keyword_rules',
                'confidence': round(confidence, 2),
                'routing_notes': reason,
            }

        intake_keywords = {'intake', 'client_intake', 'client-profile', 'questionnaire', 'subject_intake'}
        background_keywords = {'background', 'due_diligence', 'osint', 'open_source', 'skiptrace', 'profile_report'}
        contract_keywords = {'contract', 'agreement', 'retainer', 'engagement', 'scope_of_work'}
        billing_keywords = {'invoice', 'billing', 'timesheet', 'mileage', 'expense', 'accounts_receivable'}
        field_note_keywords = {'field_note', 'surveillance_log', 'observation', 'shift_report', 'daily_log'}
        data_report_keywords = {'data_report', 'analysis', 'export', 'summary_report', 'open_records', 'inquiry'}
        geo_keywords = {'map', 'aerial', 'satellite', 'street_view', 'geo', 'location'}
        communication_keywords = {'email', 'correspondence', 'sms', 'text_message', 'chat', 'imessage'}

        if contains_any(intake_keywords):
            add_tags('intake', 'client_data')
            add_related('section_2', 'section_5', 'section_7')
            return finalize('section_1', 'document', reason='Intake form detected via filename keywords', confidence=0.85)

        if contains_any(background_keywords):
            add_tags('background', 'subject_profile')
            add_related('section_2', 'section_3', 'section_4', 'section_5', 'section_7')
            return finalize('section_1', 'document', reason='Background report detected via filename keywords', confidence=0.8)

        if contains_any(contract_keywords):
            add_tags('contract', 'retainer')
            add_related('section_1', 'section_6')
            return finalize('section_5', 'document', reason='Contract or agreement document', confidence=0.9)

        if contains_any(billing_keywords) or (file_ext in spreadsheet_exts and 'billing' in filename):
            add_tags('billing', 'financials')
            add_related('section_5')
            return finalize('section_6', 'data', reason='Billing or expense document', confidence=0.85)

        if contains_any(field_note_keywords):
            add_tags('field_notes', 'surveillance')
            add_related('section_4', 'section_6')
            return finalize('section_3', 'document', reason='Field or surveillance notes', confidence=0.82)

        if contains_any(data_report_keywords) or file_ext in spreadsheet_exts:
            add_tags('data_report', 'open_records')
            add_related('section_3', 'section_7')
            return finalize('section_4', 'data', reason='Data report or open records finding', confidence=0.78)

        if contains_any(communication_keywords) or file_ext in email_exts:
            add_tags('communication', 'correspondence')
            add_related('section_3', 'section_6')
            return finalize('section_5', 'communication', reason='Email or message correspondence', confidence=0.8)

        if file_ext in image_exts:
            add_tags('media', 'photo')
            add_related('section_2', 'section_6', 'section_7')
            return finalize('section_8', 'image', reason='Image file routed to Section 8 media catalog', confidence=0.88)

        if file_ext in video_exts:
            add_tags('media', 'video', 'surveillance')
            add_related('section_2', 'section_6', 'section_7', 'section_3')
            return finalize('section_8', 'video', reason='Video file routed to Section 8 media catalog', confidence=0.88)

        if file_ext in audio_exts:
            add_tags('media', 'audio', 'surveillance')
            add_related('section_3', 'section_6')
            return finalize('section_3', 'audio', reason='Audio evidence defaulted to operational section', confidence=0.7)

        if contains_any(geo_keywords):
            add_tags('geo', 'map', 'location')
            add_related('section_8', 'section_6')
            return finalize('section_2', 'document', reason='Geospatial reference material', confidence=0.76)

        if file_ext in doc_exts:
            add_tags('document')
            add_related('section_5', 'section_7')
            return finalize('section_5', 'document', reason='General document routed to appendix', confidence=0.6)

        add_tags('uncategorized')
        add_related('section_5')
        return finalize('section_cp', 'other', reason='Unclassified artifact', confidence=0.4)

    def index_evidence(self, file_path, classification):































        """Index evidence in the Central Command system with section validation"""































        evidence_id = f"evidence_{len(self.evidence_index) + 1:04d}"































        assigned_section = classification.get("assigned_section", "unassigned")































        # Validate section against SECTION_REGISTRY































        if assigned_section != "unassigned" and assigned_section not in SECTION_REGISTRY:































            self.logger.warning(f"Invalid section {assigned_section} not in SECTION_REGISTRY, defaulting to section_cp")































            assigned_section = "section_cp"































            classification["assigned_section"] = assigned_section































        # Get section metadata from registry































        section_metadata = SECTION_REGISTRY.get(assigned_section, {})































        self.evidence_index[evidence_id] = {































            "file_path": file_path,































            "classification": classification,































            "assigned_section": assigned_section,































            "section_title": section_metadata.get("title", "Unknown Section"),































            "section_tags": section_metadata.get("tags", []),































            "timestamp": datetime.now().isoformat(),































            "status": "indexed",































            "file_size": os.path.getsize(file_path) if os.path.exists(file_path) else 0,































            "file_type": Path(file_path).suffix.lower()































        }































        self._update_common_pool_cache(evidence_id, self.evidence_index[evidence_id])
        self.logger.info(f"[INDEX] Evidence {evidence_id} indexed to {assigned_section} - {section_metadata.get('title', 'Unknown')}")































        return evidence_id































    def get_section_registry(self) -> Dict[str, Any]:































        """Get the section registry for other modules"""































        return SECTION_REGISTRY































    def get_reporting_standards(self) -> Dict[str, Any]:































        """Get the configured reporting standards for report types."""































        return REPORTING_STANDARDS































    def validate_section_id(self, section_id: str) -> bool:































        """Validate section ID against SECTION_REGISTRY"""































        return section_id in SECTION_REGISTRY or section_id == "unassigned"































    def extract_text_from_image(self, file_path):































        """Use Tesseract OCR to extract text"""































        if not OCR_AVAILABLE:































            self.logger.warning("OCR not available - pytesseract not installed")































            return ""































        try:































            text = pytesseract.image_to_string(file_path)































            self.logger.info(f"[OCR] Extracted text from {file_path}: {text[:100]}")































            return text































        except Exception as e:































            self.logger.error(f"OCR failed: {e}")































            return ""































    def extract_frames_from_video(self, file_path):































        """Use moviepy to get duration and key frames"""































        if not VIDEO_AVAILABLE:































            self.logger.warning("Video processing not available - moviepy not installed")































            return {}































        try:































            clip = VideoFileClip(file_path)































            duration = clip.duration































            self.logger.info(f"[VIDEO] Video {file_path} duration: {duration:.2f}s")































            return {"duration": duration}































        except Exception as e:































            self.logger.error(f"Video analysis failed: {e}")































            return {}































    def extract_structure_from_document(self, file_path):































        """Use unstructured to extract document layout"""































        if not UNSTRUCTURED_AVAILABLE:































            self.logger.warning("Document structure extraction not available - unstructured not installed")































            return []































        try:































            elements = partition(filename=file_path)































            self.logger.info(f"[DOC] Extracted {len(elements)} structural blocks from {file_path}")































            return elements































        except Exception as e:































            self.logger.error(f"Structure extraction failed: {e}")































            return []































    def build_manifest(self, output_path, case_id=None):































        """Build case manifest for Central Command system"""































        manifest = {































            "case_id": case_id or f"case_{datetime.now().strftime('%Y%m%d_%H%M%S')}",































            "timestamp": datetime.now().isoformat(),































            "evidence_count": len(self.evidence_index),































            "evidence_index": self.evidence_index,































            "processing_log": self.processing_log,































            "system_status": {































                "ocr_available": OCR_AVAILABLE,































                "video_available": VIDEO_AVAILABLE,































                "unstructured_available": UNSTRUCTURED_AVAILABLE































            }































        }































        try:































            os.makedirs(os.path.dirname(output_path), exist_ok=True)































            with open(output_path, 'w') as f:































                json.dump(manifest, f, indent=2)































            self.logger.info(f"[MANIFEST] Saved manifest to {output_path}")































            return manifest































        except Exception as e:































            self.logger.error(f"Failed to save manifest: {e}")































            return None































    def process_evidence_comprehensive(self, file_path: str) -> Dict[str, Any]:































        """Comprehensive evidence processing using all available OCR tools"""































        try:































            file_ext = os.path.splitext(file_path)[1].lower()































            processing_result = {































                'file_path': file_path,































                'file_type': file_ext,































                'processed_at': datetime.now().isoformat(),































                'ocr_text': '',































                'video_analysis': {},































                'document_structure': [],































                'classification': {},































                'tools_used': []































            }































            # OCR Processing for images and PDFs































            if file_ext in ['.png', '.jpg', '.jpeg', '.tiff', '.bmp', '.pdf']:































                if OCR_AVAILABLE:































                    ocr_text = self.extract_text_from_image(file_path)































                    processing_result['ocr_text'] = ocr_text































                    processing_result['tools_used'].append('tesseract')































                    self.logger.info(f"[OCR] Processed {file_path}")































            # Video Analysis































            if file_ext in ['.mp4', '.avi', '.mov', '.wmv']:































                if VIDEO_AVAILABLE:































                    video_analysis = self.extract_frames_from_video(file_path)































                    processing_result['video_analysis'] = video_analysis































                    processing_result['tools_used'].append('moviepy')































                    self.logger.info(f"[VIDEO] Analyzed {file_path}")































            # Document Structure Analysis































            if file_ext in ['.pdf', '.docx', '.doc', '.txt']:































                if UNSTRUCTURED_AVAILABLE:































                    document_structure = self.extract_structure_from_document(file_path)































                    processing_result['document_structure'] = document_structure































                    processing_result['tools_used'].append('unstructured')































                    self.logger.info(f"[DOC] Structure extracted from {file_path}")































            # Auto-classification based on content































            classification = self.classify_evidence(file_path)































            processing_result['classification'] = classification































            # Index the evidence































            evidence_id = self.index_evidence(file_path, classification)































            processing_result['evidence_id'] = evidence_id































            # Log the processing































            self.processing_log.append({































                'timestamp': datetime.now().isoformat(),































                'file_path': file_path,































                'evidence_id': evidence_id,































                'tools_used': processing_result['tools_used'],































                'status': 'processed'































            })































            self.logger.info(f"[EVIDENCE] Comprehensive processing completed for {file_path}")































            return processing_result































        except Exception as e:































            self.logger.error(f"Comprehensive processing failed for {file_path}: {e}")































            return {'error': str(e), 'file_path': file_path}































    def get_status(self):































        """Get Evidence Locker status for Central Command"""































        return {































            "evidence_count": len(self.evidence_index),































            "processing_log_count": len(self.processing_log),































            "capabilities": {































                "ocr": OCR_AVAILABLE,































                "video": VIDEO_AVAILABLE,































                "unstructured": UNSTRUCTURED_AVAILABLE































            },































            "last_activity": self.processing_log[-1]["timestamp"] if self.processing_log else None































        }































    def _call_out_to_ecc(self, operation: str, data: Dict[str, Any]) -> Dict[str, Any]:































        """Call out to ECC for permission to perform operation"""































        try:































            # Use bus if available, otherwise fallback to direct ECC































            if self.bus:































                call_out_data = {































                    "operation": operation,































                    "source": "evidence_locker_main",































                    "data": data,































                    "timestamp": datetime.now().isoformat()































                }































                self.bus.emit("evidence_locker.call_out", call_out_data)































                self.logger.info(f" Called out via bus for operation: {operation}")































                return {"permission_granted": True, "request_id": None}































            elif ECC and hasattr(ECC, 'emit'):































                call_out_data = {































                    "operation": operation,































                    "source": "evidence_locker_main",































                    "data": data,































                    "timestamp": datetime.now().isoformat()































                }































                ECC.emit("evidence_locker.call_out", call_out_data)































                self.logger.info(f" Called out to ECC for operation: {operation}")































                return {"permission_granted": True, "request_id": None}































            else:































                self.logger.warning("Neither bus nor ECC available for call-out")































                return {"permission_granted": True, "request_id": None}  # Default to allow































        except Exception as e:































            self.logger.error(f"Failed to call out: {e}")































            return {"permission_granted": True, "request_id": None}  # Default to allow































    def _send_message(self, message_type: str, data: Dict[str, Any]) -> bool:































        """Send message via bus or ECC"""































        try:































            message_data = {































                "message_type": message_type,































                "source": "evidence_locker_main",































                "data": data,































                "timestamp": datetime.now().isoformat()































            }































            # Use bus if available, otherwise fallback to direct ECC































            if self.bus:































                self.bus.emit(f"evidence_locker.{message_type}", message_data)































                self.logger.info(f" Sent message via bus: {message_type}")































                return True































            elif ECC and hasattr(ECC, 'emit'):































                ECC.emit(f"evidence_locker.{message_type}", message_data)































                self.logger.info(f" Sent message to ECC: {message_type}")































                return True































            else:































                self.logger.warning("Neither bus nor ECC available for message sending")































                return False































        except Exception as e:































            self.logger.error(f"Failed to send message: {e}")































            return False































    def _send_accept_signal(self, operation: str, data: Optional[Dict[str, Any]] = None) -> bool:















        """Send accept signal via bus or ECC"""















        try:















            accept_data = {















                "operation": operation,















                "source": "evidence_locker_main",















                "status": "accepted",















                "timestamp": datetime.now().isoformat()















            }















            if data is not None:















                accept_data["data"] = data















            if self.bus:















                self.bus.emit("evidence_locker.accept", accept_data)















                self.logger.info(f"Sent accept signal via bus for operation: {operation}")















                return True















            if ECC and hasattr(ECC, 'emit'):















                ECC.emit("evidence_locker.accept", accept_data)















                self.logger.info(f"Sent accept signal to ECC for operation: {operation}")















                return True















            self.logger.warning("Neither bus nor ECC available for accept signal")















            return False















        except Exception as e:















            self.logger.error(f"Failed to send accept signal: {e}")















            return False















    def _complete_handoff(self, operation: str, status: Optional[str] = None, data: Optional[Dict[str, Any]] = None) -> bool:















        """Complete handoff process"""















        try:















            if isinstance(status, dict) and data is None:















                data = status















                status = data.get("status")















            status = status or "completed"















            handoff_data = {















                "operation": operation,















                "source": "evidence_locker_main",















                "status": status,















                "timestamp": datetime.now().isoformat()















            }















            if data is not None:















                handoff_data["data"] = data















            self.processing_log.append({















                "timestamp": datetime.now().isoformat(),















                "operation": operation,















                "status": status,















                "type": "handoff_completion",















                "data": data or {}















            })















            self.logger.info(f"[HANDOFF] Completed {operation} with status {status}")















            return True















        except Exception as e:















            self.logger.error(f"Failed to complete handoff: {e}")















            return False















    def _handoff_to_gateway(self, file_path, evidence_id, section_hint, classification):















        """Handoff processed evidence to Gateway Controller using full protocol"""















        try:















            call_out_result = self._call_out_to_ecc("evidence_handoff", {















                "file_path": file_path,















                "evidence_id": evidence_id,















                "section_hint": section_hint,  # Hint, not final assignment















                "classification": classification















            })















            if not call_out_result.get("permission_granted", False):















                self.logger.error("ECC permission denied for evidence handoff")















                return False















            confirm_result = self._wait_for_ecc_confirm("evidence_handoff", call_out_result.get("request_id"))















            if not confirm_result.get("confirmed", False):















                self.logger.error("ECC confirmation timeout for evidence handoff")















                return False















            handoff_data = {















                "operation": "evidence_locker_processing_complete",















                "file_path": file_path,















                "evidence_id": evidence_id,















                "section_hint": section_hint,















                "classification": classification,















                "evidence_index": self.evidence_index.get(evidence_id, {}),















                "processing_log": self.processing_log[-1] if self.processing_log else {},















                "dependencies_cleared": classification.get("dependencies_cleared", True),















                "timestamp": datetime.now().isoformat(),















            }















            if not self._send_message("evidence_handoff", handoff_data):















                self.logger.error("Failed to send evidence handoff message")















                return False















            if not self._send_accept_signal("evidence_handoff", handoff_data):















                self.logger.error("Failed to send accept signal")















                return False















            if GATEWAY and hasattr(GATEWAY, 'register_evidence_locker_handoff'):















                GATEWAY.register_evidence_locker_handoff(















                    from_module="evidence_locker_main",















                    to_module="gateway_controller",















                    handoff_data=handoff_data,















                )















            self._complete_handoff("evidence_handoff", "success", handoff_data)















            self.logger.info(f"[HANDOFF] Evidence {evidence_id} handed to Gateway Controller (hint: {section_hint})")















            return True















        except Exception as e:















            self.logger.error(f"Failed to handoff to Gateway Controller: {e}")















            self._complete_handoff("evidence_handoff", "error", {















                "error": str(e),















                "file_path": file_path,















                "evidence_id": evidence_id,















            })















            return False

    # ------------------------------------------------------------------
    # Universal Communication Protocol Methods
    # ------------------------------------------------------------------
    def process_evidence_with_communication(self, evidence_data: Dict[str, Any]) -> Dict[str, Any]:
        """Process evidence using universal communication protocol"""
        try:
            # Send evidence received signal
            self.communicator.send_signal(
                target_address="2-1",  # ECC
                radio_code="10-6",
                message="Evidence received for processing",
                payload={"evidence_data": evidence_data}
            )
            
            # Process evidence
            result = self.process_evidence(evidence_data)
            
            # Send evidence complete signal
            self.communicator.send_signal(
                target_address="2-1",  # ECC
                radio_code="10-8",
                message="Evidence processing complete",
                payload={"result": result}
            )
            
            return result
            
        except Exception as e:
            # Send SOS fault with precise diagnostic code
            fault_code = f"1-1-30-{self._get_line_number()}"
            self.communicator.send_sos_fault(
                fault_code=fault_code,
                description=f"Evidence processing error: {str(e)}",
                details={"error": str(e), "evidence_data": evidence_data}
            )
            raise

    def start_new_case_with_communication(self, case_id: str) -> None:
        """Start new case using universal communication protocol"""
        try:
            # Send case start signal
            self.communicator.send_signal(
                target_address="Bus-1",
                radio_code="10-4",
                message=f"Starting new case: {case_id}",
                payload={"case_id": case_id, "operation": "start_new_case"}
            )
            
            # Clear evidence pool
            self.start_new_case(case_id)
            
            # Send case start complete signal
            self.communicator.send_signal(
                target_address="Bus-1",
                radio_code="10-8",
                message=f"New case started: {case_id}",
                payload={"case_id": case_id, "status": "complete"}
            )
            
        except Exception as e:
            # Send SOS fault
            fault_code = f"1-1-30-{self._get_line_number()}"
            self.communicator.send_sos_fault(
                fault_code=fault_code,
                description=f"Case start error: {str(e)}",
                details={"case_id": case_id, "error": str(e)}
            )
            raise

    def get_communication_status(self) -> Dict[str, Any]:
        """Get communication status for health monitoring"""
        return {
            "address": "1-1",
            "status": "ACTIVE",
            "last_check": self.communicator.get_module_status()["last_check"],
            "communication_log_count": len(self.communicator.communication_log),
            "active_signals_count": len(self.communicator.active_signals)
        }

    def _get_line_number(self) -> int:
        """Get current line number for fault reporting"""
        import inspect
        frame = inspect.currentframe()
        caller_frame = frame.f_back.f_back if frame.f_back else frame
        return caller_frame.f_lineno


from bus_extensions import inject_bus_extensions
inject_bus_extensions(EvidenceLocker)












